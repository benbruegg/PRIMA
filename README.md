# Prima_SS22


* Title: Highway Racer
* Author: Benjamin Brüggemann
* Year and season (Summer, Winter): SoSe 23
* Curriculum and semester: MIB7
* Course this development was created in: PRIMA
* Docent: Prof. Dipl.-Ing. Jirka R. Dell'Oro-Friedl
* [Application Link](https://benbruegg.github.io/Prima_SS22/HighwayRacer/index.html) 
* [source code](https://github.com/benbruegg/Prima_SS22/tree/main/HighwayRacer)
* [design document / User Control, Interaction]()



## Checklist


| Nr | Criterion           | Explanation                                                                                                                                     |   |
| -- | --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------|---|
|  1 | Units and Positions | That setup was used because it comes in handy to place the users car on the 0 position so the distance to the right and left end of the highway are the same, also by using 1 as a step from lane to lane that made placing obstacles on the exact lanes easier.                                                            
|  2 | Hierarchy           | Graphs are set up like this: 

				      Game (Contains all the objects in the game)
 					-Car 
  				          -Exhaust
 					-Obstacles
  					  - obstacles 
 					-Road
 					-Landscape
 					-Sounds

			     Like this I keep a structured organization, mostly self explaining. The Car has a child in Exhaust handling some additional aspect of the car. 
                             obstacles are only created at runtime and added to the Node Obstacles to be able to call them more easily iterating through the Obstacles node, making obstacle handling way easier.
                             The Road has a separate node as it is being animated by a spritesheet added at runtime - while Landscape just contains a basic background texture.
                             The Sound node contains all sounds played in the game, as being a top down 2d game I didn´t need any sound coming from different angles.

                             This approach makes it easy referencing the nodes and their properties comfortably.                                                              
|  3 | Editor              | The editor was used to build the basic node structure of the game, as seen above in the Graph part. fixed nodes that only appear once in the game were created there, like the car, Road or Sounds nodes. Textures that don´t change, like the Car texture and the Landscape texture were 			                     added in the editor, aswell as the Sounds I used the editor to turn the files (images or audio files) into ressources and them to the node to later reference them in the code. Adding textures over the editor like this is much easier than in coding, saving a lot of code lines. 
                             Coding is then used mainly to create obstacles at random, and the main gameplay logic like moving all the necessary nodes and handling the scenarious like collision checking etc. 
                             Also sprites like for the road or some created obstacles are generated by coding as that´s not possible in the editor. (at my current state)

|  4 | Scriptcomponents    | I created a ComponentScript in a new file (Pulsing.ts) to then add it to my car node over the editor and also to every obstacle created at runtime where I had to add that script in the code then though. ( insert code line here when done ) 
                             So as I only used it in the editor on one node it was not extremely useful and could have been done in the code aswell.        
                                             
|  5 | Extend              | All the obstacles created are of type FudgeCore.Node ( code line )
                             also the UI controller Interface class GameState is extending the Mutable class ( code line ) 
                             very useful in both cases, as every obstacle needed to be able to be handled like a node in translation or adding components to it, while having it´s own properties like the passed boolean that´s needed to calculate the score accordingly and only count an object once when passed already                               and an obstacleSpeedModifier to adjust the nodes speed for each separate obstacle.      
                
|  6 | Sound               | Sounds are, as explained in the Graph section, attached to one local Sounds node as it´s a top down 2d game there was no need to add them to different nodes and have them perceived from different spots.
                             There are sounds for different events or situations like: 
                                - car engine sound of the user car
                                - passing sound when passing by an obstacle 
                                - crashing sound when colliding 
                                - some obstacle specific sounds                                        
|  7 | VUI                 | Interface Controller class used in my GameState.ts extending the Mutable class as explained under Extend.

                             The interface shows different values at runtime like:
                                - the Score (counts up 1 for every obstacle passed)
                                - the current speed of the car (in km/h)
                                - Distance travelled of the car (in km)

                             Also there is a game over window showing the final score and giving the option to restart the game, which only shows when a collision ocurred and the game has ended.   
                                           
|  8 | Event-System        | apart from the common DOM event system used in several occasions I used the fudge Event System in following scenarios: 

                             in the collision detection logic, whenever a collision is detected the car node dispatches an event together with information about the node it collided with ( which was not used in the end) (code line) 
                             the event travels up the graph to be able to be handled on the graph node and leads to a game Over
		
|  9 | External Data       | the config.json which is read by the Interface Config set up in Main.ts includes some variables to test and mainly making balancing and debugging more easily accessible by changing these values in the config file. 
                             values set are: 
                               - gameSpeed (influencing the speed of the game at a whole, by influencing the speed of the obstacles traversing, the sprite framerate of the road and the intervals obstacles are created over time) 
                               - obstacleSpeed (sets the speed of the obstacles in y direction at the start of the game, still being increased over time influenced by the gameSpeed)

                             choosing these two values against each other especially for balacing the perception of how fast the the car and obstacles are moving and the speed in km/h in the UI compares to the perception.       
                      
|  A | Light               | 
                             as it´s a simple 2D game I just used ShaderLit and ShaderLitTextured to create already lit materials of all the objects in game, without using spotlights or any other lighting choices. The game is supposed to take part in the open on the road in an consistent lit comic styled 2D scene,                              which makes the use of shaderLit sufficient.
                                                                     
|  B | Physics             | Add rigidbody components and work with collisions (1) and/or forces and torques (1) and/or joints (1)                                           
|  C | Net                 | Add multiplayer functionality via network (3)                                                                                                   
|  D | State Machines      | Create autonomous entities using the StateMachine (1) and/or ComponentStateMachine (1) defined in FudgeAid                                      
|  E | Animation           | Sprites are used for several animations in the game:

                               - the road is generated with a sprite so it appears like the user is moving along it, getting faster over time by increasing its framerate. (code lines)
                               - the exhaust of the car to generate some smoke when the car is driving forward ( code lines ) 
                               - the police car obstacle to animate the its siren lights ( code lines )                                                 



	

		


