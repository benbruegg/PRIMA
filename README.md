# PRIMA

* Title: Highway Racer   
* Author: Benjamin Brüggemann
* Year and season (Summer, Winter): SoSe 23
* Curriculum and semester: MIB7
* Course this development was created in: PRIMA
* Docent: Prof. Dipl.-Ing. Jirka R. Dell'Oro-Friedl
* [Application Link](https://benbruegg.github.io/PRIMA/HighwayRacer/index.html) 
* [source code](https://github.com/benbruegg/PRIMA/tree/main/HighwayRacer)
* [design document](https://benbruegg.github.io/PRIMA/HighwayRacer/Docs/PRIMA_Design_Document.pdf)
* [Controls / How To Play](https://benbruegg.github.io/PRIMA/HighwayRacer/Docs/controls.png)


## Checklist
		
| Nr | Criterion          | Explanation                                                                                                                                                                                                                                                                                                                                                                                                  |
|----|--------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Units and Positions| 0 = bottomcenter, 1 = one highway lane: That setup was used because it comes in handy to place the user's car on the 0 position so the distance to the right and left end of the highway are the same. Also, by using 1 as a step from lane to lane, it made placing obstacles on the exact lanes easier, aswell as creating the sprite for the road by excactly putting the pixels of lane to represent 1 unit in the game.                                                                                                                                                  |
| 2  | Hierarchy          | Graphs are set up like this: <br>- Game <br> &nbsp;&nbsp;- Obstacles <br> &nbsp;&nbsp;&nbsp;&nbsp;- obstacles <br> &nbsp;&nbsp;- Sound <br> &nbsp;&nbsp;- Car <br> &nbsp;&nbsp;&nbsp;&nbsp;- Exhaust <br> &nbsp;&nbsp;- Road <br> &nbsp;&nbsp;- Landscape <br> <br> Like this, I keep an organized mostly self-explaining structure. The Car has a child in Exhaust handling some additional aspects of the car. Obstacles are only created at runtime and added to the Node Obstacles to be able to call them more easily, iterating through the Obstacles node, making obstacle handling way easier. The Road has a separate node as it is being animated by a sprite sheet added at runtime, while Landscape just contains a basic background texture. The Sound node contains all sounds played in the game, as being a top-down 2D game, I didn't need any sound coming from different angles. This approach makes it easy to reference the nodes and their properties comfortably. |
| 3  | Editor             | The editor was used to build the basic node structure of the game, as seen above in the Graph part. Fixed nodes that only appear once in the game were created there, like the Car, Road, or Sound nodes. Textures that don't change, like the Car texture and the Landscape texture, were added in the editor. Also, for adding the sounds, I used the editor to turn the files (images or audio files) into resources and then added them to the node to later reference them in the code. Adding textures over the editor like this is much easier than in coding, saving a lot of code lines. Coding is then used mainly to create obstacles at random and the main gameplay logic like moving all the necessary nodes and handling the scenarios like collision checking, etc. Also, sprites like for the road or some created obstacles are generated by coding as that's not possible in the editor (at my current state).                                                                                                                                                                                   |
| 4  | Script Components  | I created a ComponentScript in a new file (Pulsing.ts) to then add it to my car node over the editor and also to every obstacle created at runtime (Main.ts:59) - it´s transforming each node it´s added to so it gets a pulsing movement making it seem more vivid. So, as I only used it in the editor on one node, it was not extremely useful and could have been done in the code as well.                                                                                                                                                                                  
| 5  | Extend             | All the obstacles created are of type FudgeCore.Node (Main.ts:55). Also, the UI controller Interface class GameState is extending the Mutable class (GameState.ts:5). This proves very useful in both cases, as every obstacle needed to be able to be handled like a node in translation or adding components to it, while having specific properties like the passed boolean or an obstacleSpeedModifier to adjust the node's speed for each separate obstacle.                                              |
| 6  | Sound              | Sounds are, as explained in the Graph section, attached to one local Sounds node as it's a top-down 2D game. There was no need to add them to different nodes and have them perceived from different spots. There are sounds for different events or situations like: <br>- Car engine sound of the user car <br>- Passing sound when passing by an obstacle <br>- Crashing sound when colliding <br>- Some obstacle-specific sounds. (declare sounds: Main.ts:128++, play or stopped sounds: Main.ts:270/277/293/294/344)                                                                                                                                                                                                                                        |
| 7  | VUI                | Interface Controller class used in my GameState.ts extending the Mutable class as explained under Extend. The interface shows different values at runtime like: <br>- The Score (counts up 1 for every obstacle passed) <br>- The current speed of the car (in km/h) <br>- Distance traveled by the car (in km) <br> Also, there is a game over window showing the final score and giving the option to restart the game, which only shows when a collision occurred and the game has ended. Other VUI elements: - Tutorial                                                                                                                                                                                                                                    |
| 8  | Event System       | Apart from the common DOM event system used in several occasions, I used the fudge Event System in the following scenarios: <br>- In the collision detection logic, whenever a collision is detected, the car node dispatches an event together with information about the node it collided with  (Main.ts:271-275). This event gets listened to on the graph node level (Main.ts:115).The handleCollision function right now is not doing anything else than dispatching the game Over event right now, as I may plan to use the handleCollision function in the future. Also included whenever the car drives forward with W or Arrow Up key when the exhaust node is dispatching an event (Main.ts:235) to trigger its animation by activating the node, event gets listened to by the graph node(Main.ts: 110). Not necessary, but included it to make sure the event system functionality was included.                                                                                                                                                                                                                                                             |
| 9  | External Data      | The config.json, which is read by the Interface Config set up in Main.ts(Main.ts:9), includes some variables to test and mainly makes balancing and debugging more easily accessible by changing these values in the config file. Values set are: <br>- gameSpeedModifier (influencing the speed of the game as a whole by using it as a factor in the logarithmic function of the gameSpeed(Main.ts: 175), which then is influencing the speed of the obstacles traversing, the sprite framerate of the road, and the intervals obstacles are created over time) <br>- obstacleSpeed (Main.ts:178 - sets the speed of the obstacles in the y direction at the start of the game, still being increased over time influenced by the gameSpeed) <br>- creationInterval - sets the starting intervaltime for the time between created obstacles(Main.ts:407-408) <br> Choosing these values balancing them out against each other, especially for balancing the perception of how fast the car and obstacles are in sync with the speed in km/h in the VUI and adjusting the difficulty of the game.                                                                                                                                                                |
| A  | Light              | As it's a simple 2D game, I just used ShaderLit and ShaderLitTextured to create already lit materials of all the objects in the game, without using spotlights or any other lighting choices. The game is supposed to take part in the open on the road in a consistently lit comic-styled 2D scene, which makes the use of ShaderLit sufficient.  For example in creating the obstacle material.(Main.ts:71)                                                                                                                                                                                                         |
| B  | Physics            | Physics wasn't used in the game as, for a simple 2D game, I used simple collision detection by comparing x and y values.                                                                                                                                                                                                                                                                                       |
| C  | Net                | Multiplayer not needed, as it's meant to be a single-player game, therefore not included.                                                                                                                                                                                                                                                                                                                      |
| D  | State Machines     | State Machines haven't been used.                                                                                                                                                                                                                                                                                                                                                                              |
| E  | Animation          | Sprites are used for several animations in the game: <br>- The road is generated with a sprite, so it appears like the user is moving along it, getting faster over time by increasing its framerate (Main.ts:415). <br>- The exhaust of the car is used to generate some smoke when the car is driving forward (Main.ts:434). <br>- The police car obstacle is animated with its siren lights (Main.ts:452).   



